# Terraform

# Terraform: Up & Running

**DevOps** - это набор процессов, идей и методик. Цель DevOps — значительно повысить эффективность доставки ПО. Движение DevOps основано на четырех принципах: культуре, автоматизации, измерении и разделении. Задача — автоматизировать как можно больше аспектов процесса доставки программного обеспечения.

Инструменты IaC
- специализированные скрипты;
- средства управления конфигурацией;
- средства шаблонизации серверов;
- средства оркестрации;
- средства инициализации ресурсов.

Преимущества инфраструктуры как кода
- Самообслуживание
- Скорость и безопасность
- Документация
- Управление версиями
- Проверка
- Повторное использование
- Радость

**Как работает Terraform**

Terraform — это инструмент с открытым исходным кодом от компании HashiCorp, написанный на языке программирования Go. Код на Go компилируется в единый двоичный файл с предсказуемым названием terraform. Этот файл позволяет развернуть инфраструктуру прямо с вашего ноутбука или сборочного сервера (либо любого другого компьютера), и для всего этого не требуется никакой дополнительной инфраструктуры. Terraform использует инфраструктуру, которую провайдеры предоставляют для своих API-серверов, а также их механизмы аутентификации.


**Установка Terraform**

https://www.terraform.io - выберите подходящий пакет для своей операционной системы, сохраните ZIP-архив и распакуйте его в папку, в которую хотите установить Terraform. Архив содержит единственный двоичный файл под названием terraform, который следует добавить в переменную среды PATH.

Чтобы система Terraform могла вносить изменения в вашу учетную запись AWS, нужно прописать в переменных среды AWS_ACCESS_KEY_ID и AWS_SECRET_ACCESS_KEY

**Развертывание одного сервера**

Код Terraform пишется на языке конфигурации HashiCorp и хранится в файлах с расширением .tf. Это декларативный язык, поэтому ваша задача — описать нужную вам инфраструктуру, а Terraform разберется с тем, как ее создать.

Первым делом при использовании Terraform обычно следует выбрать провайдера (одного или несколько), с которым вы хотите работать. Создайте пустую папку и поместите в нее файл с именем main.tf
```
   provider "aws" {
     region = "us-east-2"
}
```
Это говорит Terraform о том, что в качестве провайдера вы собираетесь использовать AWS и хотите развертывать свою инфраструктуру в регионе us-east-2. Регионы AWS — это отдельные географические области. Внутри каждой области находится несколько изолированных вычислительных центров, известных как зоны доступности.

Каждый тип провайдеров поддерживает создание разного вида ресурсов. Обобщенный синтаксис создания ресурса в Terraform выглядит так:
```
resource "<PROVIDER>_<TYPE>" "<NAME>" {
      [CONFIG ...]
}
```
- PROVIDER — имя провайдер
- TYPE — тип ресурса
- NAME — идентификатор
- CONFIG содержит один или несколько аргументов, предусмотренных специально для этого ресурса
```
terraform init
```
Исполняемый файл terraform поддерживает основные команды Terraform, но он не содержит никакого кода для провайдеров (вроде AWS, Azure или GCP). Поэтому, начиная работу с этим инструментом, вы должны выполнить **terraform init**, чтобы он мог просканировать ваш код, определить, с какими провайдерами вы работаете, и загрузить для них подходящие модули. По умолчанию код провайдеров загружается в папку .terraform.
```
terraform plan
```
Команда plan позволяет увидеть, что сделает Terraform, без внесения каких-либо изменений - знак плюс (+) помечает все, что будет создано; знак минус (-) — что будет удалено, а то, что помечено тильдой (~), будет изменено. Символы -/+ в выводе плана означают «заменить».

Чтобы инициировать создание сервера, нужно выполнить команду **terraform apply**

Запустить скрипт Hello, World в рамках конфигурации пользовательских данных вашего сервера EC2. Вы можете передать параметру user_data в коде Terraform то, что будет выполнено при загрузке сервера: либо скрипт командной оболочки, либо директиву cloud-init.
```
user_data = <<-EOF
                 #!/bin/bash
                 echo "Hello, World" > index.html
                 nohup busybox httpd -f -p 8080 &
                 EOF
```
Чтобы ваш сервер мог принимать запросы на порте 8080, необходимо создать группу безопасности:
```
resource "aws_security_group" "instance" { ... }
```
Этот код создает новый ресурс под названием aws_security_group. Создания группы безопасности как таковой будет недостаточно. Нужно сделать так, чтобы сервер EC2 ее использовал. Для этого вы должны передать ее идентификатор аргументу vpc_security_group_ids ресурса aws_instance.

В Terraform выражением является все, что возвращает значение. Вы уже видели простейший тип выражений — литералы, такие как строки и числа.

Особенно полезным типом выражений является ссылка, которая позволяет обращаться к значениям с других участков кода. Чтобы указать ID группы безопасности, нужно сослаться на атрибут ресурса с помощью такого синтаксиса:
```
   <PROVIDER>_<TYPE>.<NAME>.<ATTRIBUTE>
```
- PROVIDER — это имя провайдера
- TYPE — это тип ресурса
- NAME — имя этого ресурса
- ATTRIBUTE — это либо один из аргументов ресурса
```
vpc_security_group_ids = [aws_security_group.instance.id]
```
Ссылаясь в одном ресурсе на другой, вы создаете неявную зависимость. Terraform анализирует такие зависимости, строит из них граф и применяет его для автоматического определения порядка, в котором должны создаваться ресурсы.

Можете даже вывести граф зависимостей с помощью команды graph:
```
terraform graph
```
Чтобы можно было сделать ваш код более конфигурируемым и отвечающим принципу DRY, Terraform позволяет определять входные переменные.
```
  variable "NAME" {
     [CONFIG ...]
}
```
Тело объявления переменной может содержать три необязательных параметра:
- description - Этот параметр всегда желательно указывать для документирования
- default - Вы можете присвоить значение переменной несколькими способами, в том числе через командную строку (с помощью параметра -var), файл (указывая параметр -var-file) или переменную среды (Terraform ищет переменные среды вида TF_VAR_<имя_переменной>). Если переменная не инициализирована, ей присваивается значение по умолчанию.
- type - Позволяет применить к переменным, которые передает пользователь, ограничения типов. Terraform поддерживает ряд ограничений для таких типов, как string, number, bool, list, map, set, object, tuple и any. Если тип не указан, Terraform воспринимает значение как any.
```
terraform plan -var "server_port=8080"
export TF_VAR_server_port=8080
```
Указать ссылку внутри строкового литерала можно с помощью строковой интерполяции, которая имеет следующий синтаксис:
```
"${...}"
```
Помимо входных переменных, Terraform позволяет определять и выходные.
```
 output "<NAME>" {
     value = <VALUE>
      [CONFIG ...]
   }
```
- NAME — это имя выходной переменной
- VALUE можно указать любое выражение
- CONFIG может иметь два дополнительных параметра
  - description - для документирования
  - sensitive - Если присвоить данному параметру true, Terraform не станет сохранять этот вывод в журнал после выполнения команды terraformapply. Это полезно, когда переменная содержит конфиденциальные данные.

**terraform output** - вывод списка всех выходных значений без применения каких-либо изменений.

Значение определенной выходной переменной, можно воспользоваться командой terraform output <ИМЯ_ПЕРЕМЕННОЙ>:
```
terraform output public_ip
```
**create_before_destroy** - полезный параметр жизненного цикла - Если присвоить ему true, Terraform поменяет порядок замены ресурсов на противоположный. В итоге сначала будет создана замена и только потом произойдет удаление старого ресурса.
```
lifecycle {
       create_before_destroy = true
}
```
Cервис Elastic Load Balancer (ELB) - балансировщик нагрузки, который будет распределять трафик между вашими серверами и предоставлять всем вашим пользователям собственный IP-адрес

AWS предлагает три типа балансировщиков нагрузки.
- Application Load Balancer (ALB). Лучше всего подходит для балансировки трафика по протоколам HTTP и HTTPS. Работает на прикладном уровне (уровень 7) сетевой модели OSI.
- Network Load Balancer (NLB). Лучше всего подходит для балансировки трафика по протоколам TCP, UDP и TLS. Если сравнивать с ALB, может быстрее масштабироваться в обе стороны в зависимости от нагрузки. Работает на транспортном уровне сетевой модели OSI.
- Classic Load Balancer (CLB). Это «старый» балансировщик нагрузки, который появился раньше, чем ALB и NLB. Он способен работать с трафиком по протоколам HTTP, HTTPS, TCP и TLS, но ограничен в возможностях по сравнению со своими «преемниками». Работает как на прикладном, так и на транспортном уровне сетевой модели OSI.

ALB состоит из нескольких частей
- Прослушиватель (слушатель). Прослушивает определенные порты (например, 80) и протокол (скажем, HTTP).
- Правило прослушивателя. Берет запросы, направленные к прослушивателю, и передает те из них, которые соответствуют определенным путям или сетевым именам, заданным целевым группам.
- Целевые группы. Один или несколько серверов, которые принимают запросы от балансировщика нагрузки.

**Удаление ненужных ресурсов**
```
terraform destroy - удалить все созданные вами ресурсы
```
## Как управлять состоянием Terraform
**Что собой представляет состояние Terraform**

При каждом своем запуске система Terraform записывает информацию о созданной ею инфраструктуре в свой файл состояния. По умолчанию, если запуск происходит в /foo/bar, Terraform создает файл /foo/bar/terraform.tfstate. Этот файл имеет нестандартный формат JSON и связывает ресурсы Terraform в ваших конфигурационных файлах с их представлением в реальном мире.

**Файл состояния** — это приватный API, который меняется с каждым новым выпуском и предназначен сугубо для внутреннего использования в Terraform. Вы никогда не должны редактировать его вручную или считывать его напрямую.

Проблемы с файлом состояния:
- Общее хранилище для файлов состояния. Чтобы обновлять инфраструктуру с помощью Terraform, у каждого члена команды должен быть доступ к одним и тем же файлам состояния.
- Блокирование файлов состояния. Без блокирования это может привести к конфликтам, потере данных и повреждению файлов состояния.
- Изоляция файлов состояния. При изменении инфраструктуры рекомендуется изолировать разные окружения.

**Общее хранилище для файлов состояния**

Для совместного управления файлами состояния лучше использовать удаленные хранилища, поддержка которых встроена в Terraform. Хранилище определяет то, как Terraform загружает и сохраняет свое состояние. По умолчанию для этого применяется локальное хранилище. Но поддерживаются также удаленные хранилища с возможностью совместного доступа.

Удаленные хранилища решают все три проблемы, перечисленные выше.
- Человеческий фактор. После конфигурации удаленного хранилища Terraform будет автоматически загружать из него файл состояния при каждом выполнении команд plan и apply и аналогично сохранять его туда после выполнения apply.
- Блокирование. Большинство удаленных хранилищ имеют встроенную поддержку блокирования. При выполнении terraformapply Terraform автоматически устанавливает блокировку. Команду apply можно ввести с параметром - lock-timeout=<TIME> (-lock-timeout=10m). Так Terraform будет знать, сколько времени нужно ждать снятия блокировки
- Конфиденциальные данные. Большинство удаленных хранилищ имеют встроенную поддержку активного и пассивного шифрования файлов состояния.

Чтобы включить удаленное хранение состояния в Amazon S3, для начала нужно подготовить бакет S3.
```
resource "aws_s3_bucket" "terraform_state" {
   bucket = "terraform-up-and-running-state"
   lifecycle {
      prevent_destroy = true
   }
   versioning {
       enabled = true
   }
   server_side_encryption_configuration {
      rule {
         apply_server_side_encryption_by_default {
            sse_algorithm = "AES256"
         }
      }
   }
}
```
- **bucket** - Это имя бакета S3. Имейте в виду, что имена бакетов должны быть уникальными на глобальном уровне среди всех клиентов AWS.
- **prevent_destroy** - Это параметр жизненного цикла
- **versioning** - В данном разделе включается управления версиями в бакете S3
- **server_side_encryption_configuration** - В этом разделе включается шифрование по умолчанию на стороне сервера для всех данных, которые записываются в бакет S3.

Чтобы хранить состояние в бакете S3
```
   terraform {
     backend "<BACKEND_NAME>" {
        [CONFIG...]
     }
}
```
- BACKEND_NAME — это имя хранилища
- CONFIG содержит один или несколько аргументов, предусмотренных специально для этого хранилища

**Изоляция файлов состояния**

Файлы состояния можно изолировать двумя способами:
- Изоляция через рабочие области.
- Изоляция с помощью описания структуры файлов.

**Изоляция через рабочие области**

Вы можете хранить свое состояние Terraform в нескольких отдельных именованных рабочих областях. Чтобы создать новую рабочую область или переключиться между областями, нужно выполнить команду terraform workspace.
```
terraform workspace show - показывает, в какой рабочей области вы сейчас находитесь
terraform workspace new example1 - создадим новую рабочую область над названием example1
```
Файлы состояния в каждой рабочей области изолированы друг от друга и, поскольку вы теперь в рабочей области example1, Terraform больше не использует файл состояния из рабочей области по умолчанию.
```
terraform workspace list - список областей
terraform workspace select - переключение между областями
terraform workspace select example1
```
Вы можете даже сделать так, чтобы этот модуль менял свое поведение в зависимости от того, в какой рабочей области вы находитесь. Для этого он может считывать имя рабочей области с помощью выражения terraform.workspace.
```
instance_type = terraform.workspace == "default" ? "t2.medium" : "t2.micro"
```
Код использует тернарный синтаксис.

Недостатки рабочих областей:
- Файлы состояния всех ваших рабочих областей находятся в одном и том же хранилище
- Рабочие области не видны в коде или терминале без использования команд terraform workspace
- Из двух предыдущих пунктов вытекает тот факт, что рабочие области могут быть довольно сильно предрасположены к ошибкам.

**Изоляция с помощью описания структуры файлов**
- Поместить конфигурационные файлы Terraform для каждой среды в отдельную папку.
- Предусмотреть для каждой среды разные хранилища с разными механизмами аутентификации и управления доступом

Стандартные окружения:
- stage — среда для предпромышленной нагрузки (тестирование).
- prod — среда для промышленной нагрузки (приложения, взаимодействующие с пользователями).
- mgmt — среда для инструментария DevOps (например, узел- бастион, Jenkins).
- global — папка с ресурсами, которые используются во всех средах (скажем, S3, IAM).

Внутри каждого окружения есть отдельные папки для каждого компонента.
- vpc — сетевая топология для этой среды.
- services — приложения или микросервисы
- data-storage — хранилища данных для этой среды

Внутри каждого компонента находятся конфигурационные файлы Terraform
- variables.tf — входные переменные.
- outputs.tf — выходные переменные.
- main.tf — ресурсы.

**Источник данных terraform_remote_state**

Источник, terraform_remote_state, особенно полезен при работе с состоянием. С его помощью можно извлечь файл состояния, который является частью другой конфигурации Terraform, и сделать это сугубо для чтения.

Два способа передачи конфиденциальных данных в ресурсы Terraform.
- Первый способ для работы с конфиденциальными данными заключается в применении источника Terraform, который считывает их из секретного хранилища
```
aws_secretsmanager_secret_version
password = data.aws_secretsmanager_secret_version.db_password.secret_string
data "aws_secretsmanager_secret_version" "db_password" {
     secret_id = "mysql-master-password-stage"
   }
```
- Второй способ работы с конфиденциальными данными — полный вынос управления ими за пределы Terraform. и передача их в систему в виде переменных среды. Для этого нужно объявить переменную под названием db_password. Входной переменной, определенной в конфигурации Terraform можно предоставить значение, которое берется из переменной среды.
```
export TF_VAR_db_password=" (YOUR_DB_PASSWORD)"
```
Но есть лучший способ предотвратить случайную запись конфиденциальных данных на диск в открытом виде: хранить их в секретном хранилище, совместимом с командной строкой, таком как pass (https://www.passwordstore.org/), и безопасно считывать их оттуда в переменные среды с помощью дочерней командной оболочки:
```
export TF_VAR_db_password=$(pass database-password)
```
Terraform включает в себя ряд встроенных функций, которые можно выполнять с помощью выражения такого вида:
```
function_name (...)
```
Встраивание одного языка программирования (bash) в другой (Terraform) усложняет поддержку обоих, поэтому вынесем bash-скрипт в отдельный файл. Для этого можно использовать встроенную функцию file и источник данных template_file.

Отличным способом поэкспериментировать со встроенными функциями является использование команды terraform console. Она создает интерактивную консоль, в которой вы можете попробовать синтаксис Terraform, запросить состояние вашей инфраструктуры и сразу же получить результаты:
```
terraform console
file(<PATH>) - Эта функция читает файл с путем PATH и возвращает его содержимое в виде строки.
file("user-data.sh")
```
Источник данных template_file принимает два аргумента: template (строка, которую нужно обработать) и vars (ассоциативный массив с переменными, которые должные быть доступны во время обработки).
```
data "template_file" "user_data" {
     template = file("user-data.sh")
     vars = {
       server_port = var.server_port
       db_address = data.terraform_remote_state.db.outputs.address
       db_port = data.terraform_remote_state.db.outputs.port
} }
```

## Повторное использование инфраструктуры с помощью модулей Terraform
Terraform позволяет поместить код внутрь модуля, который можно будет повторно применять на разных участках вашей конфигурации. Модули являются ключевым аспектом написания универсального кода Terraform, который легко поддерживать и тестировать.

**Что такое модуль**

В Terraform любой набор конфигурационных файлов, размещенных в одной папке, считается модулем. Можно воспользоваться модулем используя следующий синтаксис:
```
module "<NAME>" {
     source = "<SOURCE>"
     [CONFIG ...]
}
```
- NAME — это идентификатор, который можно использовать в коде Terraform для обращения к модулю
- SOURCE — путь к коду модуля
- CONFIG состоит из одного/нескольких аргументов, предназначенных специально для этого модуля

**Входные параметры модуля**

Для установки входных переменных модуля и аргументов ресурса используется один и тот же синтаксис. Входящие переменные являются API модуля и определяют то, как он себя ведет в разных окружениях.

**Локальные переменные модулей**

Можно определить локальные значения в блоке locals:
```
  locals {
     http_port    = 80
}
```
Локальные значения позволяют назначить любому выражению Terraform имя, которое затем можно использовать в коде модуля. Такие имена видны только в самом модуле, поэтому они не имеют никакого влияния на внешний код, при этом вы не можете перезаписать их извне. Чтобы прочитать локальное значение, нужна локальная ссылка со следующим синтаксисом:
```
local.<NAME>
```
**Выходные переменные модуля**

В Terraform модули тоже могут возвращать значения. Для этого используется уже знакомый вам механизм: выходные переменные. Для обращения к выходным переменным модуля используется следующий синтаксис:
```
module.<MODULE_NAME>.<OUTPUT_NAME>
module.frontend.asg_name
```
Подводные камни

При создании модулей обращайте внимание:
- на файловые пути
- вложенные блоки

**Файловые пути**

Решить проблему путей можно с помощью выражения, известного как «ссылка на путь», которое имеет вид 
```
path. <TYPE>
```
- path.module — возвращает путь к модулю, в котором определено выражение.
- path.root — возвращает путь к корневому модулю.
- path.cwd — возвращает путь к текущей рабочей папке.

**Вложенные блоки**

При попытке одновременного использования вложенных блоков и отдельных ресурсов вы получите ошибки, когда правила маршрутизации конфликтуют и переопределяют друг друга. Поэтому вы должны выбрать что-то одно. В связи с этим ограничением при создании модуля всегда следует использовать отдельные ресурсы вместо вложенных блоков.

**Управление версиями**

Если ваши тестовая и промышленная среды ссылаются на папку с одним и тем же модулем, любое изменение в этой папке коснется и той и другой при следующем же развертывании, лучше использовать разные версии модулей

Параметр source содержал локальный файловый путь. Но, помимо файловых путей, модули Terraform поддерживают и другие виды источников, такие как URL-адреса Git/Mercurial и произвольные URL. Самый простой способ управления версиями модуля — размещение его кода в отдельном Git-репозитории

Полезной схемой именования тегов является семантическое версионирование (http://semver.org). Это система управления версиями в формате MAJOR.MINOR.PATCH (например, 1.0.4):
- версию MAJOR при внесении несовместимых изменений в API;
- версию MINOR при добавлении возможностей с соблюдением обратной совместимости;
- версию PATCH при исправлении ошибок с соблюдением обратной совместимости.

Семантическое версионирование позволяет донести до пользователей модуля, какого рода изменения вы внесли и как это сказывается на процессе обновления.

## Работа с Terraform: циклы, условные выражения, развертывание и подводные камни
Terraform предоставляет несколько элементов языка, которые позволят вам выполнять определенные виды циклов, условных выражений и развертываний. Речь идет о метапараметре count, выражениях for_each и for, блоке жизненного цикла под названием create_before_destroy, тернарном операторе и большом количестве функций.

**Циклы**

Terraform предоставляет несколько разных циклических конструкций с немного разными сценариями использования.
- Параметр count для циклического перебора ресурсов.
- Выражение for_each для циклического перебора ресурсов и их вложенных блоков.
- Выражение for для циклического перебора списков и ассоциативных массивов.
- Строковая директива for для циклического перебора списков и ассоциативных массивов внутри строк.

**Циклы с параметром count** - в Terraform и получить индекс каждой итерации в цикле, можно воспользоваться ссылкой count.index:
```
count = 3
name  = "neo.${count.index}"
```
Нужные имена пользователей IAM можно перечислить во входной переменной внутри variables.tf:
```
type        = list(string)
default     = ["neo", "trinity", "morpheus"]
```
В Terraform можно сделать с помощью count в сочетании:
- с синтаксисом доступа к массиву по индексу
```
ARRAY[<INDEX>]
var.user_names[1]
```
- с функцией length. У Terraform есть встроенная функция под названием length, которая имеет следующий синтаксис:
```
length(<ARRAY>) - функция length возвращает количество элементов в заданном массиве

count = length(var.user_names)
name  = var.user_names[count.index]
```
Обратите внимание: если в ресурсе используется параметр count, он превращается в массив ресурсов. Поэтому применяется тот же синтаксис доступа к элементам массива по его индексу:
```
<PROVIDER>_<TYPE>.<NAME>[x].<ATTRIBUTE>
```
К сожалению, у параметра count есть два ограничения, которые делают его куда менее полезным. Во-первых, с помощью count можно пройтись по всему ресурсу, но при этом нельзя перебирать его вложенные блоки. Вложенный блок — это аргумент, который устанавливается внутри ресурса в следующем формате:
```
   resource "xxx" "yyy" {
     <NAME> {
       [CONFIG...]
     }
}
```
Второе ограничение параметра count даст о себе знать, когда вы попытаетесь его изменить. Ресурс, в котором указан параметр count, превращается в список или массив ресурсов. К сожалению, Terraform определяет каждый элемент массива по его позиции.

**Циклы с выражениями for_each**

Выражение for_each позволяет выполнять циклический перебор списков, множеств и ассоциативных массивов с последующим созданием множественных копий либо всего ресурса, либо вложенного в него блока.
```
for_each = <COLLECTION>
   [CONFIG ...]
```
- COLLECTION — множество или ассоциативный массив, который нужно перебрать в цикле
- CONFIG состоит из одного или нескольких аргументов, предназначенных специально для этого ресурса. Внутри CONFIG можно применять ссылки each.key и each.value для доступа к ключу и значению текущего элемента COLLECTION.
```
for_each = toset(var.user_names)
     name     = each.value
```
Функция toset, которая превращает список var.user_names во множество. Дело в том, что выражение for_each поддерживает множества и ассоциативные массивы только для ресурсов. Ресурс, к которому применяется for_each, становится ассоциативным массивом ресурсов. Теперь есть ассоциативный массив ресурсов с for_each вместо обычного массива ресурсов с count, так как теперь вы можете безопасно удалять его элементы.

Еще одно преимущество выражения for_each: его способность создавать множественные вложенные блоки внутри ресурса.
```
dynamic "<VAR_NAME>" {
     for_each = <COLLECTION>
     content {
        [CONFIG...]
} }
```
for_each в сочетании со списком, key содержит индекс, value — элемент с этим индексом.

**Циклы на основе выражений for**

следующий базовый синтаксис:
```
[for <ITEM> in <LIST> : <OUTPUT>]
```
- LIST — это список, который нужно перебрать
- ITEM — имя локальной переменной, которое будет назначено каждому элементу списка
- OUTPUT — выражение, которое каким-то образом преобразует ITEM
```
  output "upper_names" {
     value = [for name in var.names : upper(name)]
}
```
можете задать выражение для фильтрации полученного результата:
```
value = [for name in var.names : upper(name) if length(name) < 5]
```
Выражение for в Terraform также поддерживает циклический перебор ассоциативных массивов с использованием такого синтаксиса:
```
   [for <KEY>, <VALUE> in <MAP> : <OUTPUT>]
```
Выражение for может вернуть ассоциативный массив вместо списка, используя следующий синтаксис:
```
# Циклический перебор списков
[for <ITEM> in <MAP> : <OUTPUT_KEY> => <OUTPUT_VALUE>]
# Циклический перебор ассоциативных массивов
{for <KEY>, <VALUE> in <MAP> : <OUTPUT_KEY> => <OUTPUT_VALUE>}
```
**Циклы с использованием строковой директивы for**

С помощью строковых директив подобный синтаксис можно использовать и для управляющих конструкций перед фигурными скобками указывается знак процента (%{...}). Строковая директива for имеет следующий синтаксис:
```
%{ for <ITEM> in <COLLECTION> }<BODY>%{ endfor}
```
- COLLECTION — список или ассоциативный массив, который нужно перебрать
- ITEM — имя локальной переменной, которое назначается каждому элементу COLLECTION
- BODY — это то, что выводится на каждой итерации
```
output "for_directive" {
   value = <<EOF
%{ for name in var.names }
   ${name}
%{ endfor }
EOF
}
```
Обратите внимание на дополнительные символы перехода на новую строку. В строковой директиве можно указать маркер ~, чтобы удалить все пробельные символы перед ней или после нее.
```
%{~ for name in var.names }
   ${name}
%{~ endfor }
```
**Условные выражения**
- Параметр count для условных ресурсов.
- Выраженияfor_eachиfor для условных ресурсов и их вложенных блоков.
- Строковая директива if для условных выражений внутри строк.

- Если внутри ресурса параметру count присвоить значение 1, вы получите копию этого ресурса; если указать 0, этот ресурс вообще не будет создан.
- Terraform поддерживает условные выражения в формате <CONDITION>?<TRUE_VAL>:<FALSE_VAL>. Это тернарный синтаксис. Он проверит булеву логику в CONDITION и, если результат равен true, вернет TRUE_VAL; в противном случае возвращается FALSE_VAL.
```
count = format("%.1s", var.instance_type) == "t" ? 1 : 0
length(data.template_file.user_data[*]) > 0
```
**Условные выражения с использованием строковой директивы if**
```
%{ if <CONDITION> }<TRUEVAL>%{ endif }
```
- CONDITION — это любое выражение, возвращающее булево значение
- TRUEVAL — выражение, которое нужно вывести, если CONDITION равно true.
```
%{ if <CONDITION> }<TRUEVAL>%{ else } <FALSEVAL>%{ endif }
```
- FALSEVAL — это выражение, которое выводится, если CONDITION равно false

**Параметры count и for_each имеют ограничения**
- В count и for_each нельзя ссылаться ни на какие выходные переменные ресурса.
- count и for_each нельзя использовать в конфигурации модуля.

Terraform требует, чтобы count и for_each вычислялись на этапе планирования, до создания или изменения каких-либо ресурсов. Это означает, что count и for_each могут ссылаться на литералы, переменные, источники данных и даже списки ресурсов, но не на вычисляемые выходные переменные ресурса.

**Корректный план может быть неудачно реализован**

Ключевым моментом является то, что команда terraformplan учитывает только те ресурсы, которые указаны в файле состояния Terraform. Если ресурсы созданы каким-то другим способом, они не попадут в файл состояния и, следовательно, Terraform не будет их учитывать при выполнении команды plan.
- Если вы уже начали работать с Terraform, не используйте ничего другого. Если часть вашей инфраструктуры управляется с помощью Terraform, больше нельзя изменять ее вручную.
- Если у вас уже есть какая-то инфраструктура, используйте команду import. Если вы начинаете использовать Terraform с уже существующей инфраструктурой, ее можно добавить в файл состояния с помощью команды **terraform import**.

Команда import принимает два аргумента. 
- Первым служит адрес ресурса в ваших конфигурационных файлах. Здесь тот же синтаксис, что и в ссылках на ресурсы: <PROVIDER>_<TYPE>.<NAME>
- Второй аргумент — это идентификатор ресурса, который нужно импортировать.

**Рефакторинг может иметь свои подвохи**

Рефакторинг — распространенная практика в программировании, когда вы меняете внутреннюю структуру кода, оставляя внешнее поведение без изменения. Это нужно чтобы сделать код более понятным, опрятным и простым в обслуживании. Рефакторинг — это незаменимая методика, которую следует регулярно применять.

Если поменять параметр name в каком-то ресурсе, Terraform удалит старую версию этого ресурса и создаст вместо него новую. Но если таким ресурсом является ALB, в период между его удалением и загрузкой новой версии у вас не будет механизма для перенаправления трафика к вашему веб- серверу. Точно так же, если удаляется группа безопасности, ваши серверы начнут отклонять любой сетевой трафик, пока не будет создана новая группа.

Terraform связывает ID каждого ресурса с идентификатором облачного провайдера. Если изменить идентификатор ресурса, для Terraform это будет выглядеть так, будто вы удалили старый ресурс и добавили новый.
- Всегда используйте команду plan. Ею можно выявить все эти загвоздки. Тщательно просматривайте ее вывод и обращайте внимание на ситуации, когда Terraform планирует удалить ресурсы, которые, скорее всего, удалять не стоит.
- Создавайте, прежде чем удалять. Если вы хотите заменить ресурс, хорошенько подумайте, нужно ли создавать замену до удаления оригинала. Если ответ положительный, в этом может помочь create_before_destroy.
- Изменение идентификаторов требует изменения состояния. Если вы хотите поменять идентификатор, связанный с ресурсом избегая при этом удаления ресурса и создания его новой версии, необходимо соответствующим образом обновить файл состояния Terraform. При переименовании идентификаторов следует выполнить команду terraformstatemv, которая имеет следующий синтаксис:
```
terraform state mv <ORIGINAL_REFERENCE> <NEW_REFERENCE>
```
  - ORIGINAL_REFERENCE — это выражение, ссылающееся на ресурс в его текущем виде
  - NEW_REFERENCE — то место, куда вы хотите его переместить
  - Если после переименования и запуска этой команды terraformplan не покажет никаких изменений, значит, вы все сделали правильно.
- Некоторые параметры нельзя изменять. Параметры многих ресурсов неизменяемые. Если попытаться их изменить, Terraform удалит старый ресурс и создаст вместо него новый.

## Код Terraform промышленного уровня
Под инфраструктурой промышленного уровня я имею в виду серверы, хранилища данных, балансировщики нагрузки, механизмы безопасности, средства мониторинга и оповещения, процедуры сборки и любые другие составляющие вашей технологии, без которых не может обойтись ваша компания.

При оценке времени, которое может уйти на разработку проекта промышленного уровня, нужно учитывать следующее.
- Если вы хотите развернуть сервис, который будет полностью управляться третьим лицом, на его подготовку к промышленному использованию может уйти от одной до двух недель.
- Если вы хотите сами запускать свое распределенное приложение, которое не хранит состояние, как в случае с кластером Node.js без каких-либо локальных данных запущенным поверх группы автомасштабирования AWS (ASG), для его подготовки к промышленному использованию понадобится где-то вдвое больше времени, или около четырех недель.
- Если вы хотите сами запускать свое распределенное приложение с сохранением состояния, как в случае с кластером Amazon Elasticsearch (Amazon ES) поверх ASG, который хранит данные на локальных дисках, вам потребуется на порядок больше времени — от двух до четырех месяцев.
- Если вы хотите разработать целую архитектуру, включая все свои приложения, хранилища данных, балансировщики нагрузки, мониторинг, механизм оповещения, безопасность и т. д., необходимое время увеличивается еще на 1–2 порядка —примерно от 6 до 36 месяцев работы.

**Почему построение инфраструктуры промышленного уровня требует так много времени**
- DevOps как индустрия все еще находится в каменном веке. Все эти средства и методики относительно новые и быстро развивающиеся. Значит, они не совсем зрелые и глубокими знаниями в этой области обладает не так уж много людей
- Вторая причина — DevOps, похоже, особенно подвержен эффекту стрижки быка (yak shaving) - в какой-то мере это связано с тем, что термин DevOps охватывает поразительно широкий спектр тем: от сборки до развертывания, обеспечения безопасности и т. д.
- Третья причина, почему DevOps занимает столько времени, состоит в том, что для подготовки инфраструктуры к промышленному использованию необходимо решить довольно длинный список задач. Проблема в том, что множество разработчиков не догадываются о большей части пунктов в этом списке, поэтому при оценке сроков выполнения проекта они забывают об огромном количестве критически важных деталей, которые отнимают много времени.

**Инфраструктурные модули промышленного уровня**








